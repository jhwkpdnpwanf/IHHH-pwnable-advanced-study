# Exploit Tech: Tcache Poisoning

**실습 환경**
```Dockerfile
FROM ubuntu:18.04

ENV PATH="${PATH}:/usr/local/lib/python3.6/dist-packages/bin"
ENV LC_CTYPE=C.UTF-8

RUN apt update
RUN apt install -y \
    gcc \
    git \
    python3 \
    python3-pip \
    ruby \
    sudo \
    tmux \
    vim \
    wget

# install pwndbg
WORKDIR /root
RUN git clone https://github.com/pwndbg/pwndbg
WORKDIR /root/pwndbg
RUN git checkout 2023.03.19
RUN ./setup.sh

# install pwntools
RUN pip3 install --upgrade pip
RUN pip3 install pwntools

# install one_gadget command
RUN gem install one_gadget -v 1.6.2

WORKDIR /root
COPY . /root
```

```bash
$ IMAGE_NAME=ubuntu1804 CONTAINER_NAME=my_container; \
docker build . -t $IMAGE_NAME; \
docker run -d -t --privileged --name=$CONTAINER_NAME $IMAGE_NAME; \
docker exec -it -u root $CONTAINER_NAME bash
```

<br>


**실습 코드**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
  void *chunk = NULL;
  unsigned int size;
  int idx;

  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);

  while (1) {
    printf("1. Allocate\n");
    printf("2. Free\n");
    printf("3. Print\n");
    printf("4. Edit\n");
    scanf("%d", &idx);

    switch (idx) {
      case 1:
        printf("Size: ");
        scanf("%d", &size);
        chunk = malloc(size);
        printf("Content: ");
        read(0, chunk, size - 1);
        break;
      case 2:
        free(chunk);
        break;
      case 3:
        printf("Content: %s", chunk);
        break;
      case 4:
        printf("Edit chunk: ");
        read(0, chunk, size - 1);
        break;
      default:
        break;
    }
  }

  return 0;
}
```

```bash
pwndbg> checksec
[*] '/root/tcache_poison'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

<br>


**코드 분석**

우선 코드를 살펴보면 `free(chunk);`로 `free`에 해당하는 `case 2`가 존재한다.   

또한 나머지 1 3 4 case에서 동적할당, 텍스트 편집, printf 등 여러 기능이 존재하니, `if (__glibc_unlikely (e->key == tcache))` 만 만족하도록 조작해준다면 double free 가 일어날 것으로 보인다.   

그러니 일단 DFB를 만들고, 그 이후에 ROP 체인을 만들든 원가젯을 쓰든지 해서 플래그를 얻어내는 식으로 풀 수 있을 거 같다. 얼추 방향을 잡았으니 동적 분석으로 답을 찾아나가보자.  

<br>

**동적 분석**

```nasm
pwndbg> disass main
Dump of assembler code for function main:
   0x0000000000400737 <+0>:     push   rbp
   0x0000000000400738 <+1>:     mov    rbp,rsp
   0x000000000040073b <+4>:     sub    rsp,0x20
   0x000000000040073f <+8>:     mov    rax,QWORD PTR fs:0x28
   0x0000000000400748 <+17>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000040074c <+21>:    xor    eax,eax
   0x000000000040074e <+23>:    mov    QWORD PTR [rbp-0x10],0x0
   0x0000000000400756 <+31>:    mov    rax,QWORD PTR [rip+0x2008c3]        # 0x601020 <stdin@@GLIBC_2.2.5>
   0x000000000040075d <+38>:    mov    ecx,0x0
   0x0000000000400762 <+43>:    mov    edx,0x2
   0x0000000000400767 <+48>:    mov    esi,0x0
   0x000000000040076c <+53>:    mov    rdi,rax
   0x000000000040076f <+56>:    call   0x400630 <setvbuf@plt>
   0x0000000000400774 <+61>:    mov    rax,QWORD PTR [rip+0x200895]        # 0x601010 <stdout@@GLIBC_2.2.5>
   0x000000000040077b <+68>:    mov    ecx,0x0
   0x0000000000400780 <+73>:    mov    edx,0x2
   0x0000000000400785 <+78>:    mov    esi,0x0
   0x000000000040078a <+83>:    mov    rdi,rax
   0x000000000040078d <+86>:    call   0x400630 <setvbuf@plt>
   0x0000000000400792 <+91>:    lea    rdi,[rip+0x1bb]        # 0x400954
   0x0000000000400799 <+98>:    call   0x4005f0 <puts@plt>
   0x000000000040079e <+103>:   lea    rdi,[rip+0x1bb]        # 0x400960
   0x00000000004007a5 <+110>:   call   0x4005f0 <puts@plt>
   0x00000000004007aa <+115>:   lea    rdi,[rip+0x1b7]        # 0x400968
   0x00000000004007b1 <+122>:   call   0x4005f0 <puts@plt>
   0x00000000004007b6 <+127>:   lea    rdi,[rip+0x1b4]        # 0x400971
   0x00000000004007bd <+134>:   call   0x4005f0 <puts@plt>
   0x00000000004007c2 <+139>:   lea    rax,[rbp-0x14]
   0x00000000004007c6 <+143>:   mov    rsi,rax
   0x00000000004007c9 <+146>:   lea    rdi,[rip+0x1a9]        # 0x400979
   0x00000000004007d0 <+153>:   mov    eax,0x0
   0x00000000004007d5 <+158>:   call   0x400640 <__isoc99_scanf@plt>
   0x00000000004007da <+163>:   mov    eax,DWORD PTR [rbp-0x14]
   0x00000000004007dd <+166>:   cmp    eax,0x2
   0x00000000004007e0 <+169>:   je     0x400872 <main+315>
   0x00000000004007e6 <+175>:   cmp    eax,0x2
   0x00000000004007e9 <+178>:   jg     0x4007f5 <main+190>
   0x00000000004007eb <+180>:   cmp    eax,0x1
   0x00000000004007ee <+183>:   je     0x40080c <main+213>
   0x00000000004007f0 <+185>:   jmp    0x4008c5 <main+398>
   0x00000000004007f5 <+190>:   cmp    eax,0x3
   0x00000000004007f8 <+193>:   je     0x400880 <main+329>
   0x00000000004007fe <+199>:   cmp    eax,0x4
   0x0000000000400801 <+202>:   je     0x40089a <main+355>
   0x0000000000400807 <+208>:   jmp    0x4008c5 <main+398>
   0x000000000040080c <+213>:   lea    rdi,[rip+0x169]        # 0x40097c
   0x0000000000400813 <+220>:   mov    eax,0x0
   0x0000000000400818 <+225>:   call   0x400600 <printf@plt>
   0x000000000040081d <+230>:   lea    rax,[rbp-0x18]
   0x0000000000400821 <+234>:   mov    rsi,rax
   0x0000000000400824 <+237>:   lea    rdi,[rip+0x14e]        # 0x400979
   0x000000000040082b <+244>:   mov    eax,0x0
   0x0000000000400830 <+249>:   call   0x400640 <__isoc99_scanf@plt>
   0x0000000000400835 <+254>:   mov    eax,DWORD PTR [rbp-0x18]
   0x0000000000400838 <+257>:   mov    eax,eax
   0x000000000040083a <+259>:   mov    rdi,rax
   0x000000000040083d <+262>:   call   0x400620 <malloc@plt>
   0x0000000000400842 <+267>:   mov    QWORD PTR [rbp-0x10],rax
   0x0000000000400846 <+271>:   lea    rdi,[rip+0x136]        # 0x400983
   0x000000000040084d <+278>:   mov    eax,0x0
   0x0000000000400852 <+283>:   call   0x400600 <printf@plt>
   0x0000000000400857 <+288>:   mov    eax,DWORD PTR [rbp-0x18]
   0x000000000040085a <+291>:   sub    eax,0x1
   0x000000000040085d <+294>:   mov    edx,eax
   0x000000000040085f <+296>:   mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000400863 <+300>:   mov    rsi,rax
   0x0000000000400866 <+303>:   mov    edi,0x0
   0x000000000040086b <+308>:   call   0x400610 <read@plt>
   0x0000000000400870 <+313>:   jmp    0x4008c5 <main+398>
   0x0000000000400872 <+315>:   mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000400876 <+319>:   mov    rdi,rax
   0x0000000000400879 <+322>:   call   0x4005e0 <free@plt>
   0x000000000040087e <+327>:   jmp    0x4008c5 <main+398>
   0x0000000000400880 <+329>:   mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000400884 <+333>:   mov    rsi,rax
   0x0000000000400887 <+336>:   lea    rdi,[rip+0xff]        # 0x40098d
   0x000000000040088e <+343>:   mov    eax,0x0
   0x0000000000400893 <+348>:   call   0x400600 <printf@plt>
   0x0000000000400898 <+353>:   jmp    0x4008c5 <main+398>
   0x000000000040089a <+355>:   lea    rdi,[rip+0xf8]        # 0x400999
   0x00000000004008a1 <+362>:   mov    eax,0x0
   0x00000000004008a6 <+367>:   call   0x400600 <printf@plt>
   0x00000000004008ab <+372>:   mov    eax,DWORD PTR [rbp-0x18]
   0x00000000004008ae <+375>:   sub    eax,0x1
   0x00000000004008b1 <+378>:   mov    edx,eax
   0x00000000004008b3 <+380>:   mov    rax,QWORD PTR [rbp-0x10]
   0x00000000004008b7 <+384>:   mov    rsi,rax
   0x00000000004008ba <+387>:   mov    edi,0x0
   0x00000000004008bf <+392>:   call   0x400610 <read@plt>
   0x00000000004008c4 <+397>:   nop
   0x00000000004008c5 <+398>:   jmp    0x400792 <main+91>
```

일단은 메모리를 할당해주고 `e->key == tcache` 같은 조건을 상세하게 확인해보면서 어딜 건드릴지 판단해보겠다.   

그럴려면 `case 1`에 들어가서 메모리 할당 이후를 봐야하니  
`main+262`에 브레이크를 걸고 `malloc` 전후 변화를 살펴본다.   





____ <임시저장용 방향 기록>___

edit(b'B'*8 + b'\x00') 으로 key 덮기 (미리 청크해제해둔 뒤)
-> libc 베이스 찾기

stdout 스트림 취약점 이용 (분석필요)

malloc이 _IO_2_1_stdout_ 주소 받게 하고 print_chunk로 청크 출력 -> leak

tcache 생각하면서 alloc으로 free 트리거로 만들어주기
free -> binsh 가 목표



























![image](https://github.com/user-attachments/assets/5e362c2b-fb1b-42b1-ba81-0a50fa9e62f8)
