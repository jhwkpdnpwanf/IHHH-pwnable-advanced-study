# Exploit Tech: Tcache Poisoning

**실습 환경**
```Dockerfile
FROM ubuntu:18.04

ENV PATH="${PATH}:/usr/local/lib/python3.6/dist-packages/bin"
ENV LC_CTYPE=C.UTF-8

RUN apt update
RUN apt install -y \
    gcc \
    git \
    python3 \
    python3-pip \
    ruby \
    sudo \
    tmux \
    vim \
    wget

# install pwndbg
WORKDIR /root
RUN git clone https://github.com/pwndbg/pwndbg
WORKDIR /root/pwndbg
RUN git checkout 2023.03.19
RUN ./setup.sh

# install pwntools
RUN pip3 install --upgrade pip
RUN pip3 install pwntools

# install one_gadget command
RUN gem install one_gadget -v 1.6.2

WORKDIR /root
COPY . /root
```

```bash
$ IMAGE_NAME=ubuntu1804 CONTAINER_NAME=my_container; \
docker build . -t $IMAGE_NAME; \
docker run -d -t --privileged --name=$CONTAINER_NAME $IMAGE_NAME; \
docker exec -it -u root $CONTAINER_NAME bash
```

<br>


**실습 코드**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
  void *chunk = NULL;
  unsigned int size;
  int idx;

  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);

  while (1) {
    printf("1. Allocate\n");
    printf("2. Free\n");
    printf("3. Print\n");
    printf("4. Edit\n");
    scanf("%d", &idx);

    switch (idx) {
      case 1:
        printf("Size: ");
        scanf("%d", &size);
        chunk = malloc(size);
        printf("Content: ");
        read(0, chunk, size - 1);
        break;
      case 2:
        free(chunk);
        break;
      case 3:
        printf("Content: %s", chunk);
        break;
      case 4:
        printf("Edit chunk: ");
        read(0, chunk, size - 1);
        break;
      default:
        break;
    }
  }

  return 0;
}
```

```bash
pwndbg> checksec
[*] '/root/tcache_poison'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

<br>


**코드 분석**

우선 코드를 살펴보면 `free(chunk);`로 `free`에 해당하는 `case 2`가 존재한다.   

또한 나머지 1 3 4 case에서 동적할당, 텍스트 편집, printf 등 여러 기능이 존재하니, `if (__glibc_unlikely (e->key == tcache))` 만 만족하도록 조작해준다면 double free 가 일어날 것으로 보인다.   

그러니 일단 DFB를 만들고, 그 이후에 ROP 체인을 만들든 원가젯을 쓰든지 해서 플래그를 얻어내는 식으로 풀 수 있을 거 같다. 얼추 방향을 잡았으니 동적 분석으로 답을 찾아나가보자.  

<br>

**동적 분석**

```nasm
pwndbg> disass main
Dump of assembler code for function main:
   0x0000000000400737 <+0>:     push   rbp
   0x0000000000400738 <+1>:     mov    rbp,rsp
   0x000000000040073b <+4>:     sub    rsp,0x20
   0x000000000040073f <+8>:     mov    rax,QWORD PTR fs:0x28
   0x0000000000400748 <+17>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000040074c <+21>:    xor    eax,eax
   0x000000000040074e <+23>:    mov    QWORD PTR [rbp-0x10],0x0
   0x0000000000400756 <+31>:    mov    rax,QWORD PTR [rip+0x2008c3]        # 0x601020 <stdin@@GLIBC_2.2.5>
   0x000000000040075d <+38>:    mov    ecx,0x0
   0x0000000000400762 <+43>:    mov    edx,0x2
   0x0000000000400767 <+48>:    mov    esi,0x0
   0x000000000040076c <+53>:    mov    rdi,rax
   0x000000000040076f <+56>:    call   0x400630 <setvbuf@plt>
   0x0000000000400774 <+61>:    mov    rax,QWORD PTR [rip+0x200895]        # 0x601010 <stdout@@GLIBC_2.2.5>
   0x000000000040077b <+68>:    mov    ecx,0x0
   0x0000000000400780 <+73>:    mov    edx,0x2
   0x0000000000400785 <+78>:    mov    esi,0x0
   0x000000000040078a <+83>:    mov    rdi,rax
   0x000000000040078d <+86>:    call   0x400630 <setvbuf@plt>
   0x0000000000400792 <+91>:    lea    rdi,[rip+0x1bb]        # 0x400954
   0x0000000000400799 <+98>:    call   0x4005f0 <puts@plt>
   0x000000000040079e <+103>:   lea    rdi,[rip+0x1bb]        # 0x400960
   0x00000000004007a5 <+110>:   call   0x4005f0 <puts@plt>
   0x00000000004007aa <+115>:   lea    rdi,[rip+0x1b7]        # 0x400968
   0x00000000004007b1 <+122>:   call   0x4005f0 <puts@plt>
   0x00000000004007b6 <+127>:   lea    rdi,[rip+0x1b4]        # 0x400971
   0x00000000004007bd <+134>:   call   0x4005f0 <puts@plt>
   0x00000000004007c2 <+139>:   lea    rax,[rbp-0x14]
   0x00000000004007c6 <+143>:   mov    rsi,rax
   0x00000000004007c9 <+146>:   lea    rdi,[rip+0x1a9]        # 0x400979
   0x00000000004007d0 <+153>:   mov    eax,0x0
   0x00000000004007d5 <+158>:   call   0x400640 <__isoc99_scanf@plt>
   0x00000000004007da <+163>:   mov    eax,DWORD PTR [rbp-0x14]
   0x00000000004007dd <+166>:   cmp    eax,0x2
   0x00000000004007e0 <+169>:   je     0x400872 <main+315>
   0x00000000004007e6 <+175>:   cmp    eax,0x2
   0x00000000004007e9 <+178>:   jg     0x4007f5 <main+190>
   0x00000000004007eb <+180>:   cmp    eax,0x1
   0x00000000004007ee <+183>:   je     0x40080c <main+213>
   0x00000000004007f0 <+185>:   jmp    0x4008c5 <main+398>
   0x00000000004007f5 <+190>:   cmp    eax,0x3
   0x00000000004007f8 <+193>:   je     0x400880 <main+329>
   0x00000000004007fe <+199>:   cmp    eax,0x4
   0x0000000000400801 <+202>:   je     0x40089a <main+355>
   0x0000000000400807 <+208>:   jmp    0x4008c5 <main+398>
   0x000000000040080c <+213>:   lea    rdi,[rip+0x169]        # 0x40097c
   0x0000000000400813 <+220>:   mov    eax,0x0
   0x0000000000400818 <+225>:   call   0x400600 <printf@plt>
   0x000000000040081d <+230>:   lea    rax,[rbp-0x18]
   0x0000000000400821 <+234>:   mov    rsi,rax
   0x0000000000400824 <+237>:   lea    rdi,[rip+0x14e]        # 0x400979
   0x000000000040082b <+244>:   mov    eax,0x0
   0x0000000000400830 <+249>:   call   0x400640 <__isoc99_scanf@plt>
   0x0000000000400835 <+254>:   mov    eax,DWORD PTR [rbp-0x18]
   0x0000000000400838 <+257>:   mov    eax,eax
   0x000000000040083a <+259>:   mov    rdi,rax
   0x000000000040083d <+262>:   call   0x400620 <malloc@plt>
   0x0000000000400842 <+267>:   mov    QWORD PTR [rbp-0x10],rax
   0x0000000000400846 <+271>:   lea    rdi,[rip+0x136]        # 0x400983
   0x000000000040084d <+278>:   mov    eax,0x0
   0x0000000000400852 <+283>:   call   0x400600 <printf@plt>
   0x0000000000400857 <+288>:   mov    eax,DWORD PTR [rbp-0x18]
   0x000000000040085a <+291>:   sub    eax,0x1
   0x000000000040085d <+294>:   mov    edx,eax
   0x000000000040085f <+296>:   mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000400863 <+300>:   mov    rsi,rax
   0x0000000000400866 <+303>:   mov    edi,0x0
   0x000000000040086b <+308>:   call   0x400610 <read@plt>
   0x0000000000400870 <+313>:   jmp    0x4008c5 <main+398>
   0x0000000000400872 <+315>:   mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000400876 <+319>:   mov    rdi,rax
   0x0000000000400879 <+322>:   call   0x4005e0 <free@plt>
   0x000000000040087e <+327>:   jmp    0x4008c5 <main+398>
   0x0000000000400880 <+329>:   mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000400884 <+333>:   mov    rsi,rax
   0x0000000000400887 <+336>:   lea    rdi,[rip+0xff]        # 0x40098d
   0x000000000040088e <+343>:   mov    eax,0x0
   0x0000000000400893 <+348>:   call   0x400600 <printf@plt>
   0x0000000000400898 <+353>:   jmp    0x4008c5 <main+398>
   0x000000000040089a <+355>:   lea    rdi,[rip+0xf8]        # 0x400999
   0x00000000004008a1 <+362>:   mov    eax,0x0
   0x00000000004008a6 <+367>:   call   0x400600 <printf@plt>
   0x00000000004008ab <+372>:   mov    eax,DWORD PTR [rbp-0x18]
   0x00000000004008ae <+375>:   sub    eax,0x1
   0x00000000004008b1 <+378>:   mov    edx,eax
   0x00000000004008b3 <+380>:   mov    rax,QWORD PTR [rbp-0x10]
   0x00000000004008b7 <+384>:   mov    rsi,rax
   0x00000000004008ba <+387>:   mov    edi,0x0
   0x00000000004008bf <+392>:   call   0x400610 <read@plt>
   0x00000000004008c4 <+397>:   nop
   0x00000000004008c5 <+398>:   jmp    0x400792 <main+91>
```

일단은 메모리를 할당해주고 `e->key == tcache` 같은 조건을 상세하게 확인해보면서 어딜 건드릴지 판단해보겠다.   

그럴려면 `case 1`에 들어가서 메모리 할당 이후를 봐야하니  
`main+262`에 브레이크를 걸고 `malloc` 전후 변화를 살펴본다.   

==============================================  
==============================================  
==============================================  

일단 하던거 기록좀해두자 아오  

rop 만들거면 이거 쓰고  
0x00000000000215bf : pop rdi ; ret

원가젯 필요하면 이거 쓰고  
root@ad8b9a7fd378:~# one_gadget ./libc-2.27.so
0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
constraints:
rcx == NULL

0x4f432 execve("/bin/sh", rsp+0x40, environ)
constraints:
[rsp+0x40] == NULL

0x10a41c        execve("/bin/sh", rsp+0x70, environ)
constraints:
[rsp+0x70] == NULL



일단 계속 진행 ㄲ



<img width="1396" height="603" alt="image (7)" src="https://github.com/user-attachments/assets/de35b488-b280-4304-b181-d909fce26175" />

free에 브레이크 걸고 구조파악

<img width="1316" height="698" alt="image (6)" src="https://github.com/user-attachments/assets/81323832-9198-4285-bf15-077f450816b1" />

allocated 일때 확인

<img width="1309" height="682" alt="image (5)" src="https://github.com/user-attachments/assets/62f03c27-2495-4752-a2a4-0e851a37e1f1" />

tcache 들어갔으면 $e 걸어주고 key 확인 -> modify로 \x00이면 key 조작 가능한거 확인  
여기까진 쉬운데 하   


libc leak -> stdout 사용    


<img width="1339" height="539" alt="image (4)" src="https://github.com/user-attachments/assets/d8488733-c766-47a8-88e7-e2d4ae972c7d" />

이건 나중에 libc 하고 hook 할것들


<img width="1286" height="504" alt="image" src="https://github.com/user-attachments/assets/372ff7ce-a17f-4905-aadd-7fe33e706b94" />

진짜 뭐 어케하는지 감 1도 안잡힌다 일단 stdout 부터 어케 찾아보고  



일단 쟤 정체부터 좀 공부해옴  

setvbuf(stdout, 0, 2, 0);  <- 이놈이 걍 문제안데   
stdin, stdout은 <stdio.h>에 FILE *로 선언되어 있음.  

그말은 곧 실행하면 이 포인터들이 libc 내부에 _IO_2_1_stdout_, _IO_2_1_stdin_ 을 가리키고 쓴단거임 ..

그럼 setvbuf 함수 호출로 stdout, stdin이 코드 흐름에 노출됨.  
끝났네그럼 걍 저렇게 흐름에 호출되면 바로 libc leak 이란거네   

하 그러면 setv 없었어도 충분히 leak 여지가 잇고? 그럼 ㄹㅇ중요하단건데 ;;     


<img width="1615" height="445" alt="image" src="https://github.com/user-attachments/assets/a142d604-f438-4675-b508-879c07568cab" />

와 여기서 찾음 이렇게 하면 디버깅에서 바로 포인터 찾을순잇네  
search는 문자열 가져온거고 밑에 $ 로 찐 주소 가져온건데 libc 범위 안에잇는거 보면 구조체 포인터 맞음    

No pie니까 걍 써도되는거 아닌가 길이보인다 드뎌ㅜ  
집갓다 낼마무리해보쟈
