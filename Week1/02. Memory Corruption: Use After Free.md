# Memory Corruption: Use After Free

### Use After Free

- 메모리 참조에 사용한 포인터를 메모리 해제 후에 적절히 초기화하지 않아서 발생하는 취약점.
- 또는 해제한 메모리를 초기화하지 않고 다음 청크에 재할당해주면서 발생하는 취약점이다.
- 다른 취약점에 비해 익스플로잇 성공률이 높은 편이라 상당히 위험한 취약점이다.

<br>

### 실습 환경 Dockerfile

**Ubuntu 18.04 64-bit(Glibc 2.27) 실습 환경 Dockerfile**

```bash
FROM ubuntu:18.04

ENV PATH="${PATH}:/usr/local/lib/python3.6/dist-packages/bin"
ENV LC_CTYPE=C.UTF-8

RUN apt update
RUN apt install -y \
    gcc \
    git \
    python3 \
    python3-pip \
    ruby \
    sudo \
    tmux \
    vim \
    wget

# install pwndbg
WORKDIR /root
RUN git clone https://github.com/pwndbg/pwndbg
WORKDIR /root/pwndbg
RUN git checkout 2023.03.19
RUN ./setup.sh

# install pwntools
RUN pip3 install --upgrade pip
RUN pip3 install pwntools

# install one_gadget command
RUN gem install one_gadget -v 1.6.2

WORKDIR /root
```

<br>

**도커 이미지 빌드/컨테이너 실행/셸 실행 명령어**

```bash
$ IMAGE_NAME=ubuntu1804 CONTAINER_NAME=my_container; \
docker build . -t $IMAGE_NAME; \
docker run -d -t --privileged --name=$CONTAINER_NAME $IMAGE_NAME; \
docker exec -it -u root $CONTAINER_NAME bash
```

<br>

### Dangling Pointer

- 유효하지 않은 메모리 영역을 가리키는 포인터를 말한다.
- 메모리를 동적 할당할 때, 포인터를 선언하고 그 포인터에 `malloc` 함수가 할당한 메모리의 주소를 저장한다. 그리고 그 포인터를 참조하여 할당한 메모리에 접근한다.
- 메모리를 해제할 때는 `free` 함수를 호출한다.
- `free` 함수는 청크를 `ptmalloc`에 반환하기만 하고, 청크의 주소를 담고 있던 포인터를 초기화하지는 않는다. 
→  `free` 호출 이후 따로 포인터를 해제해주지 않으면, 포인터는 해제된 청크를 가리키는 Dangling Pointer가 된다.
- Dangling Pointer는 보안적으로 취약하다기 보단 오동장 가능성을 키우고, 이는 공격 수단이 될 가능성이 있다.

<br>

**Dangling Pointer 위험성 예제**

```c
// Name: dangling_ptr.c
// Compile: gcc -o dangling_ptr dangling_ptr.c
#include <stdio.h>
#include <stdlib.h>

int main() {
  char *ptr = NULL;
  int idx;

  while (1) {
    printf("> ");
    scanf("%d", &idx);
    switch (idx) {
      case 1:
        if (ptr) {
          printf("Already allocated\n");
          break;
        }
        ptr = malloc(256);
        break;
      case 2:
        if (!ptr) {
          printf("Empty\n");
        }
        free(ptr);
        break;
      default:
        break;
    }
  }
}
```

<br>

**실행 결과**

<img src="https://github.com/user-attachments/assets/d20d8376-edab-4ea4-8ea6-7b9846b9d6c3" width=600>  

<br>

**결과 분석**

위 예제를 보면 `ptr = malloc(256)`을 통해 256바이트 청크를 할당한다.   

그러나 `free(ptr)`을 통해 `ptr`이 가리키고 있는 힙 메모리 블록을 힙 관리자에 반환하기는 하지만, 메모리 자체의 값이 변하는건 아니다.  

조금 더 자세히 살펴보면,   
1. `ptr`은 `ptr = malloc(256)`을 통해 256 바이트 청크가 할당되어 있는 상태이다.  
2. `free(ptr)`을 통해 메모리를 반납한다.
3. in-use 상태에서 free 상태로 들어가게 된다. ← bin 에 들어간다. (단순히 청크 헤더의 inuse 플래그가 꺼지고, bin 에 들어간거지, 내부 값 사라지는건 아님. 청크 헤더만 변경된 상태)
  
따라서 위와 같은 경우에는 Dangling Pointer 위험성이 존재한다.

<br>

**동적 분석**

![image](https://github.com/user-attachments/assets/dfdd2623-9c83-45dd-ba3b-d9ef8c65b2cc)

우선 diassem 을 통해 구조를 파악해준다.  

main +67에 scanf가 호출되므로 브레이크를 걸고 1을 먼저 넣어줬다.  
그리고 `malloc`을 호출할 때 까지 쭉 넘어가주면,    

<br>

![image](https://github.com/user-attachments/assets/4d712a96-956c-4670-8c8f-6436faeac711)

`mov edi, 0x100` 으로 256바이트 크기 동적 할당을 위한 인자를 설정해주고,   
`call malloc@plt`를 통해 0x100 (256) 바이트 크기의 청크를 할당해준다.   

그리고 반환된 주소를,
`mov qword ptr [rbp - 0x10], rax`을 통해 `rbp - 0x10` 위치에 저장해두었다는 것을 알아낼 수 있다.   

또한, ptr인  $rbp-0x10는 0x0000555555602a80 주소를 가르키고 있음을 기억해두자.

<br>

![image](https://github.com/user-attachments/assets/aa909a63-b058-4703-8b7e-72a4725de89c)

이후에 scanf 호출 뒤 2를 입력해준 뒤   
`free(ptr)`을 실행 이후 `ptr`의 변화를 살펴보면,  
여전히 `ptr`인  `$rbp-0x10`는 `0x0000555555602a80` 주소를 가르키고 있음을 알 수 있다.   

즉, ptr이 가르키는 값인 주소는 변화가 없다는 것을 확인했다.  

<br>

### Use After Free

이제 해제된 메모리에 접근할 수 있을 때 발생하는 Use After Free 취약점 예제를 살펴보자.

이전 예제처럼, Dangling Pointer로 인해 발생하기도 하지만, 새롭게 할당한 영역을 초기화하지 않고 사용할 때도 발생한다.

`malloc`과 `free` 함수에는 메모리의 데이터 초기화 기능이 없기 때문에, 새롭게 할당한 청크를 명시적으로 초기화해주는 작업을 해줘야 한다.

아래 예제를 통해 자세히 알아보자.

 

**Use After Free 위험성 예제**

```c
// Name: uaf.c
// Compile: gcc -o uaf uaf.c -no-pie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct NameTag {
  char team_name[16];
  char name[32];
  void (*func)();
};

struct Secret {
  char secret_name[16];
  char secret_info[32];
  long code;
};

int main() {
  int idx;

  struct NameTag *nametag;
  struct Secret *secret;

  secret = malloc(sizeof(struct Secret));

  strcpy(secret->secret_name, "ADMIN PASSWORD");
  strcpy(secret->secret_info, "P@ssw0rd!@#");
  secret->code = 0x1337;

  free(secret);
  secret = NULL;

  nametag = malloc(sizeof(struct NameTag));

  strcpy(nametag->team_name, "security team");
  memcpy(nametag->name, "S", 1);

  printf("Team Name: %s\n", nametag->team_name);
  printf("Name: %s\n", nametag->name);

  if (nametag->func) {
    printf("Nametag function: %p\n", nametag->func);
    nametag->func();
  }
}
```
