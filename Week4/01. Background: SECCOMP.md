# Background: SECCOMP

### Sandbox

- 프로그램이나 코드가 격리된 상황에서 실행되도록 하여 시스템의 나머지 부분에 영향을 주지 않도록 제한하는 보안기법이다.
- 샌드박스는 **Allow List** 와 **Deny List** 두 가지를 선택해 적용할 수 있으며, 애플리케이션의 기능 수행에 필수인 콜 실행과 파일 접근만을 허용한다.
- 이렇게 보호된 영역에서 애플리케이션의 기능이 수행되기 때문에 외부의 공격을 최소화할 수 있는 효과를 가진다.
- 샌드박스는 개발자가 직접 명시해야되며, 만약 기능과 보안 관련 지식이 부족하다면 일부 기능이 실행되지 않거나 우회가 가능할 수도 있다.

<br>

### SECCOMP

- *SECure COMPuting mode (SECCOMP)**는 ****리눅스 커널에서 프로그램의 샌드박싱 매커니즘을 제공하는 컴퓨터 보안 가능이다.
- SECCOMP을 활용하여 불필요한 시스템 콜의 호출을 방지할 수 있다.
- 예를 들어, 외부에서 `execve`와 같은 시스템 콜이 실행될 필요가 없다면 `execve`을 실행을 방지하는 정책을 적용시킬 수 있고, 적용이 되었다면 외부의 공격으로 부터 `execve` 시스템 콜이 실행될 경우 애플리케이션을 즉시 종료한다.

<br>

**SECCOMP 구성 코드**

```c
int __secure_computing(const struct seccomp_data *sd) {
  int mode = current->seccomp.mode;
  int this_syscall;
  ...
  this_syscall = sd ? sd->nr : syscall_get_nr(current, task_pt_regs(current));
  switch (mode) {
    case SECCOMP_MODE_STRICT:
      __secure_computing_strict(this_syscall); /* may call do_exit */
      return 0;
    case SECCOMP_MODE_FILTER:
      return __seccomp_filter(this_syscall, sd, false);
    ...
  }
}

```

<br>

**STRICT_MODE**

- `read`, `write`, `exit`, `sigreturn` 시스템 콜 호출만 허용하여 이외에는 SIGKILL 시그널을 발생하고 프로그램을 종료시킨다.
<br>

**FILTER_MODE**

- 시스템 콜의 호출을 허용하거나 거부할 수 있다.
- 이를 적용하기 위해서 라이브러리 함수를 이용하거나 BPF 문법으로 작성할 수 있다.
<br>

**seccomp 설치 명령어**

```bash
apt install libseccomp-dev libseccomp2 seccomp

```

<br>

**STRICT_MODE**

```bash
// Name: strict_mode.c
// Compile: gcc -o strict_mode strict_mode.c
#include <fcntl.h>
#include <linux/seccomp.h>
#include <sys/prctl.h>
#include <unistd.h>
void init_filter() { prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT); }
int main() {
  char buf[256];
  int fd = 0;
  init_filter();
  write(1, "OPEN!\\n", 6);
  fd = open("/bin/sh", O_RDONLY);
  write(1, "READ!\\n", 6);
  read(fd, buf, sizeof(buf) - 1);
  write(1, buf, sizeof(buf));
  return 0;
}

```



<img width="1417" height="246" alt="image" src="https://github.com/user-attachments/assets/761b1139-0302-4f8c-9e5a-c1ec63632638" />

STRICT_MODE를 적용한 위 코드를 실행시켜보면,   
`init_filter()` 함수에서 `prtctl` 함수를 사용해 해당 모드를 적용한 것을 알 수 있다.  

- `void init_filter() { prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT); }`


따라서 `open`이 실행되지 않고 프로그램이 종료된 것이 확인된다.  

<br>

### **STRICT_MODE 동작 원리**  
- **STRICT_MODE** 를 처리하는 코드를 살펴보면서 어떻게 `read`, `write`, `exit`, `sigreturn` 시스템 콜의 호출만을 허용하는지 알아보자.

<br>

**STRICT_MODE 처리 과정**  
```c
static const int mode1_syscalls[] = {
    __NR_seccomp_read,
    __NR_seccomp_write,
    __NR_seccomp_exit,
    __NR_seccomp_sigreturn,
    -1, /* negative terminated */
};
#ifdef CONFIG_COMPAT
static int mode1_syscalls_32[] = {
    __NR_seccomp_read_32,
    __NR_seccomp_write_32,
    __NR_seccomp_exit_32,
    __NR_seccomp_sigreturn_32,
    0, /* null terminated */
};
#endif
static void __secure_computing_strict(int this_syscall) {
  const int *allowed_syscalls = mode1_syscalls;
#ifdef CONFIG_COMPAT
  if (in_compat_syscall()) allowed_syscalls = get_compat_mode1_syscalls();
#endif
  do {
    if (*allowed_syscalls == this_syscall) return;
  } while (*++allowed_syscalls != -1);
#ifdef SECCOMP_DEBUG
  dump_stack();
#endif
  seccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);
  do_exit(SIGKILL);
}
```

`mode1_syscalls[]` 는 `read`, `write`, `exit` `sigreturn` 시스템 콜의 번호를 저장하고 있는 변수이며, 애플리케이션의 호환 모드에 따라서 각 비트에 맞는 시스템 콜 번호를 저장한다.    

이후 애플리케이션에서 시스템 콜이 호출되면 `__secure_computing` 함수에 먼저 진입한다.  
 
해당함수는 전달된 시스템 콜 번호가 `model_syscalls` 또는 `mode1_syscalls_32`에 미리 정의된 번호와 일치하는지 검사하고, 일치하지 않는다면 바로 `SIGKILL` 시그널을 날리고 `SECCOMP_RET_KILL`을 반환한다.   

<br>

이 파트부터 Advanced 범위인데, 생각보다 진짜 개어렵다. 좀 깊이있게 먼저 공부하고 기록해야겟다
