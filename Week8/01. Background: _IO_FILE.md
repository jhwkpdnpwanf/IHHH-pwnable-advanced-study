# Background: _IO_FILE

**Ubuntu 18.04 64-bit(Glibc 2.27) 실습 환경 Dockerfile**

```docker
FROM ubuntu:18.04
ENV PATH="${PATH}:/usr/local/lib/python3.6/dist-packages/bin"
ENV LC_CTYPE=C.UTF-8
RUN apt update
RUN apt install -y \
    gcc \
    git \
    python3 \
    python3-pip \
    ruby \
    sudo \
    tmux \
    vim \
    wget
# install pwndbg
WORKDIR /root
RUN git clone https://github.com/pwndbg/pwndbg
WORKDIR /root/pwndbg
RUN git checkout 2023.03.19
RUN ./setup.sh
# install pwntools
RUN pip3 install --upgrade pip
RUN pip3 install pwntools
# install one_gadget command
RUN gem install one_gadget -v 1.6.2
# install patchelf
WORKDIR /root
RUN apt install -y dh-autoreconf
RUN git clone https://github.com/NixOS/patchelf
WORKDIR /root/patchelf
RUN git checkout 0.17.2
RUN ./bootstrap.sh
RUN ./configure
RUN make
RUN make check
RUN sudo make install
WORKDIR /root
```

```bash
CONTAINER_NAME=my_container; \
docker build . -t ubuntu1804; \
docker run -d -t --privileged --name=$CONTAINER_NAME ubuntu1804; \
docker exec -it -u root $CONTAINER_NAME bash
```

<br>

### 파일을 열 때

우리가 파일을 열어볼 때 파일 접근 유형을 명시해야 한다.   
대표적으로 읽기모드, 쓰기모드가 있는데 읽기 모드로 파일을 열고 데이터를 작성하려하면 기능이 수행되지 않는다.   
모든 파일 함수는 `fopen` 함수에서 반환한 파일 포인터를 인자로 전달받고, 기능을 수행하기 앞서 파일 포인터를 참조해 파일 정보를 확인한다.   
파일의 정보에는 파일이 열린 모드와 작업을 수행하기 위한 함수의 주소가 포함된다.    

뭐 정리하자면, 파일을 열 때 지정한 접근 모드에 따라 해당 파일에 허용된 작업이 결정된다는 뜻이다.  
예를 들어 읽기 모드 r 로 열린 파일은 내부적으로 쓰기 작업에 대한 함수 포인터가 설정되지 않으므로 fwrite 나 fputc 와 같은 함수 호출 시에 아무 작업도 수행되지 않거나 에러가 발생할 수 있다.   

실제로 파일 입출력 함수들은 내부적으로 FILE 구조체에 정의된 함수 포인터 테이블을 참조하여 동작을 위임한다. 이 테이블은 파일이 열릴 때 지정한 모드에 따라 초기화 된다.   
표준 라이브러리에서는 `_IO_FILE` 구조체 내에 `__mode`, `vtable` 등의 필드를 통해 파일의 상태와 동작을 관리하고 각 작업에 맞는 함수가 연결된다.   
허용되지 않은 작업을 시도하면 해당 동작이 무시되거나 오류를 리턴하게 될 것이다.    

그리고 이러한 동작을 보안의 관점에서 살펴보면, `_IO_FILE` 구조체는 내부적으로 다양한 함수 포인터와 버퍼 주소 등을 포함하고 있으므로 bof나 uaf 같은 취약점이 발견되어 이 구조체를 덮어버리자는 생각이 가능하다.     

vtable 에 존재하는 함수 포인터를 덮어씌우면 입출력 함수 호출 시 원하는 주소로 흐름을 바꿔버릴 수 있지않을까.  

우선 구조체 동작부터 자세히 알아보자.  

<br>

### **_IO_FILE**

- `_IO_FILE`은 리눅스 시스템의 표준 라이브러리에서 파일 스트림을 나타내기 위한 구조체이다.   
- 이는 파일을 열기 위한 `fopen` 함수를 사용할 때 **힙 영역에 할당된다**  

**_IO_FILE 구조체**

```c
struct _IO_FILE_plus
{
  FILE file;
  const struct _IO_jump_t *vtable;
};

struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```  


**구조체 멤버 변수 정리**

| 멤버 변수 | 설명 |
| --- | --- |
| `_flags` | 파일에 대한 읽기/쓰기/추가 권한을 의미하는 비트 플래그이다. 예를 들어, `0xfbad0000` 값은 매직 값으로 사용되며, 하위 2바이트는 상태 플래그로 사용된다 |
| `_IO_read_ptr` | 파일 읽기 버퍼에 대한 포인터이다 |
| `_IO_read_end` | 파일 읽기 버퍼 주소의 끝을 가리키는 포인터이다 |
| `_IO_read_base` | 파일 읽기 버퍼 주소의 시작을 가리키는 포인터이다 |
| `_IO_write_base` | 파일 쓰기 버퍼 주소의 시작을 가리키는 포인터이다 |
| `_IO_write_ptr` | 쓰기 버퍼에 대한 포인터이다 |
| `_IO_write_end` | 파일 쓰기 버퍼 주소의 끝을 가리키는 포인터이다 |
| `_chain` | 프로세스의 `_IO_FILE` 구조체는 `_chain` 필드를 통해 링크드 리스트를 구성하며, 이 리스트의 헤더는 `_IO_list_all`에 저장된다 |
| `_fileno` | 파일 디스크립터의 값이다 |
| `_IO_jump_t *vtable` | 파일 관련 작업을 수행하는 가상 함수 테이블이다 |

<br>

### **_IO_FILE: _flags**

- `_IO_FILE` 구조체에서 `_flags` 멤버 변수는 파일의 성질을 나타낸다.
- `fopen` 함수로 파일을 열 때 전달한 모드에 따라 값이 설정된다.

**_flags 비트**

```c
#define _IO_MAGIC         0xFBAD0000 /* Magic number */
#define _IO_MAGIC_MASK    0xFFFF0000
#define _IO_USER_BUF          0x0001 /* Don't deallocate buffer on close. */
#define _IO_UNBUFFERED        0x0002
#define _IO_NO_READS          0x0004 /* Reading not allowed.  */
#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */
#define _IO_EOF_SEEN          0x0010
#define _IO_ERR_SEEN          0x0020
#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don't call close(_fileno) on close.  */
#define _IO_LINKED            0x0080 /* In the list of all open files.  */
#define _IO_IN_BACKUP         0x0100
#define _IO_LINE_BUF          0x0200
#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */
#define _IO_CURRENTLY_PUTTING 0x0800
#define _IO_IS_APPENDING      0x1000
#define _IO_IS_FILEBUF        0x2000
                           /* 0x4000  No longer used, reserved for compat.  */
#define _IO_USER_LOCK         0x8000
```

**iofile.c**

```c
// Name: iofile.c
// Compile: gcc -o iofile iofile.c

#include <stdio.h>
#include <string.h>
#include <unistd.h>

void file_info(FILE *buf) {
  printf("_flags: %x\n", buf->_flags);
  printf("_fileno: %d", buf->_fileno);
}

int main() {
  FILE *fp;
  char buf[256];
  strcpy(buf, "THIS IS TESTFILE!");
  fp = fopen("testfile", "w");
  fwrite(buf, 1, strlen(buf), fp);

  file_info(fp);

  fclose(fp);
  return 0;
}
```

```c
root@e1479db93957:~/io# ./iofile
_flags: fbad2c84
_fileno: 3
```

해당 c 코드를 실행시켜보면, `fbad2c84` 라는 결과가 나오는 것을 볼 수 있다.

- `#define _IO_MAGIC         0xFBAD0000`
- `#define _IO_NO_READS          0x0004` → 0000 0000 0000 0100
- `#define _IO_LINKED            0x0080` → 0000 0000 1000 0000
- `#define _IO_TIED_PUT_GET      0x0400` → 0000 0100 0000 0000
- `#define _IO_CURRENTLY_PUTTING 0x0800` → 0000 1000 0000 0000
- `#define _IO_IS_FILEBUF        0x2000` → 0010 0000 0000 0000

이렇게 6개 플래그의 비트가 포함되어 있는 형태이다.  

0x2c84 를 비트로 쪼개보면 0010 1100 1000 0100 으로 아래 다섯개 비트를 다 더한 값과 같은 것을 볼 수 있다.  

<br>

### **_IO_FILE: _flags**

- 전에는 _flags 멤버 변수가 `fopen` 함수로 파일을 열 때 전달한 모드에 따른 값 설정이고
- 아래 코드는 `fopen` 함수가 호출될 때 실행되는 내부 함수인 `_IO_new_file_fopen` 이다.
- `fopen` 함수의 두 번째 인자인 `mode` 변수가 r w a 문자인지 확인하고 각 권한에 해당하는 비트가 할당되는 것을 확인할 수 있다.

**_IO_new_file_fopen 함수**

```c
FILE *_IO_new_file_fopen(FILE *fp, const char *filename, const char *mode,
                         int is32not64) {
  int oflags = 0, omode;
  int read_write;
  int oprot = 0666;
  int i;
  FILE *result;
  const char *cs;
  const char *last_recognized;
  if (_IO_file_is_open(fp)) return 0;
  switch (*mode) {
    case 'r':
      omode = O_RDONLY;
      read_write = _IO_NO_WRITES;
      break;
    case 'w':
      omode = O_WRONLY;
      oflags = O_CREAT | O_TRUNC;
      read_write = _IO_NO_READS;
      break;
    case 'a':
      omode = O_WRONLY;
      oflags = O_CREAT | O_APPEND;
      read_write = _IO_NO_READS | _IO_IS_APPENDING;
      break;
      ...
  }
```

더 자세히 살펴보면 `read_write` 뿐만 아니라 `omode` 변수에 `O_RDONLY` , `O_WRONLY` 등의 값이 저장되는 것을 볼 수 있다.   
`omode` 는 파일을 열 때 사용되는 내부 플래그로 파일을 열 때 전달된 전체 플래그를 담고 있다.   

<br>

### **_IO_FILE: vtable**

- virtual function table 이라는 뜻으로 메모리에 가상 함수를 담을 영역을 할당하고 함수의 주소를 기록한다.
- 가상 함수를 사용하면 해당 테이블을 기준으로 상대 주소를 통해 호출한다.

```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};
```

```bash
pwndbg> p *(struct _IO_jump_t *)0x00007ffff7dca2a0
$1 = {
  __dummy = 0,
  __dummy2 = 0,
  __finish = 0x7ffff7a6e2d0 <_IO_new_file_finish>,
  __overflow = 0x7ffff7a6f2b0 <_IO_new_file_overflow>,
  __underflow = 0x7ffff7a6efd0 <_IO_new_file_underflow>,
  __uflow = 0x7ffff7a70370 <__GI__IO_default_uflow>,
  __pbackfail = 0x7ffff7a71c00 <__GI__IO_default_pbackfail>,
  __xsputn = 0x7ffff7a6d8d0 <_IO_new_file_xsputn>,
  __xsgetn = 0x7ffff7a6d530 <__GI__IO_file_xsgetn>,
  __seekoff = 0x7ffff7a6cb30 <_IO_new_file_seekoff>,
  __seekpos = 0x7ffff7a70940 <_IO_default_seekpos>,
  __setbuf = 0x7ffff7a6c7f0 <_IO_new_file_setbuf>,
  __sync = 0x7ffff7a6c670 <_IO_new_file_sync>,
  __doallocate = 0x7ffff7a600b0 <__GI__IO_file_doallocate>,
  __read = 0x7ffff7a6d8b0 <__GI__IO_file_read>,
  __write = 0x7ffff7a6d130 <_IO_new_file_write>,
  __seek = 0x7ffff7a6c8b0 <__GI__IO_file_seek>,
  __close = 0x7ffff7a6c7e0 <__GI__IO_file_close>,
  __stat = 0x7ffff7a6d120 <__GI__IO_file_stat>,
  __showmanyc = 0x7ffff7a71d80 <_IO_default_showmanyc>,
  __imbue = 0x7ffff7a71d90 <_IO_default_imbue>
}
```

vtable 모습을 보면 이렇게 적혀있다.  

<br>


### **_IO_FILE: vtable 호출 과정**

- `_IO_jump_t` 구조체에서 vtable에 어떻게 접근하는지는 fread 함수 호출로 따라가볼 수 있다.   

**fread 호출 과정 1 - _IO_fread**

```c
#define fread(p, m, n, s) _IO_fread (p, m, n, s)
size_t
_IO_fread (void *buf, size_t size, size_t count, FILE *fp)
{
  size_t bytes_requested = size * count;
  size_t bytes_read;
  CHECK_FILE (fp, 0);
  if (bytes_requested == 0)
    return 0;
  _IO_acquire_lock (fp);
  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);
  _IO_release_lock (fp);
  return bytes_requested == bytes_read ? count : bytes_read / size;
}
```

얘는 _IO_sgetn  얘를 호출하고   


**fread 호출 과정 2 - _IO_sgetn**

```c
#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1, X2)
#define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable ( (THIS)))
size_t
_IO_sgetn (FILE *fp, void *data, size_t n)
{
  /* FIXME handle putback buffer here! */
  return _IO_XSGETN (fp, data, n);
}
```

여기서 _IO_XSGETN 를 호출하게 된다.   

_IO_XSGETN 은 vtable의 `__xsgetn` 함수 포인터를 간접 호출하여 실질적으로 파일을 읽을 수 있게 된다.  

```scss
fread()
 └── _IO_fread()
       └── _IO_sgetn(fp, data, n)
             └── _IO_XSGETN(fp, data, n)
                   └── fp->vtable->__xsgetn(fp, data, n)
                           └── _IO_file_xsgetn(...)  ← 파일 읽기

```
