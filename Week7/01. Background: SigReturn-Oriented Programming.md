# Background: SigReturn-Oriented Programming

### **SigReturn-Oriented Programming (SROP)**

- NX 보호기법 등장 이후 쉘코드를 실행이 어느정도 방지가 되니, 라이브러리 함수를 호출하여 보호기법을 우회하는 ROP 기법이 등장했다.
- SROP 는 sigreturn 시스템 콜을 악용하여 임의 코드를 실행하는 공격 기법이다.

<br>

### Signal

- SROP 에 대해 자세히 알아보기 전에, 시그널을 처리하는 방식을 이해하고 있어야 한다.
- 운영 체제는 크게 유저모드와 커널모드로 나뉘어지며, 실제로 파일을 생성하고 프로그램을 실행하는 모든 작업은 두 모드가 상호작용하면서 이뤄진다.
- 시그널은 프로세스에 특정 정보를 전달하는 매개체로 볼 수 있는데 우리가 자주 봤던 SIGSEGV 도 시그널에 포함된다.
- 아래는 리눅스에 정의된 시그널들

**include/linux/signal.h 일부**

```bash
 *	+--------------------+------------------+
 *	|  POSIX signal      |  default action  |
 *	+--------------------+------------------+
 *	|  SIGHUP            |  terminate	|
 *	|  SIGINT            |	terminate	|
 *	|  SIGQUIT           |	coredump 	|
 *	|  SIGILL            |	coredump 	|
 *	|  SIGTRAP           |	coredump 	|
 *	|  SIGABRT/SIGIOT    |	coredump 	|
 *	|  SIGBUS            |	coredump 	|
 *	|  SIGFPE            |	coredump 	|
 *	|  SIGKILL           |	terminate(+)	|
 *	|  SIGUSR1           |	terminate	|
 *	|  SIGSEGV           |	coredump 	|
 *	|  SIGUSR2           |	terminate	|
 *	|  SIGPIPE           |	terminate	|
 *	|  SIGALRM           |	terminate	|
 *	|  SIGTERM           |	terminate	|
 *	|  SIGCHLD           |	ignore   	|
 *	|  SIGCONT           |	ignore(*)	|
 *	|  SIGSTOP           |	stop(*)(+)  	|
 *	|  SIGTSTP           |	stop(*)  	|
 *	|  SIGTTIN           |	stop(*)  	|
 *	|  SIGTTOU           |	stop(*)  	|
 *	|  SIGURG            |	ignore   	|
 *	|  SIGXCPU           |	coredump 	|
 *	|  SIGXFSZ           |	coredump 	|
 *	|  SIGVTALRM         |	terminate	|
 *	|  SIGPROF           |	terminate	|
 *	|  SIGPOLL/SIGIO     |	terminate	|
 *	|  SIGSYS/SIGUNUSED  |	coredump 	|
 *	|  SIGSTKFLT         |	terminate	|
 *	|  SIGWINCH          |	ignore   	|
 *	|  SIGPWR            |	terminate	|
 *	|  SIGRTMIN-SIGRTMAX |	terminate       |
 *	+--------------------+------------------+
 *	|  non-POSIX signal  |  default action  |
 *	+--------------------+------------------+
 *	|  SIGEMT            |  coredump	|
 *	+--------------------+------------------+
```

<br>

### **시그널 동작 방식**

```bash
// Name: sig_alarm.c
// Compile: gcc -o sig_alarm sig_alarm.c 
#include<stdio.h>
#include<unistd.h>
#include<signal.h>
#include<stdlib.h>
 
void sig_handler(int signum){
  printf("sig_handler called.\n");
  exit(0);
}
int main(){
  signal(SIGALRM,sig_handler);
  alarm(5);
  getchar();
  return 0;
}
```

우리가 평소에 자주 봤던 코드다.   
문제파일을 받으면 거의 항상 저런 코드가 적혀있는데 저건 5초 뒤에 `sig_handler` 를 호출하는 코드다.    

```bash
alex030905@Janghoon-GB3Ultra:~/pwnable/SROP/tmp$ ./sig_alarm
sig_handler called.
```

이렇게 5초 뒤에 `sig_handler` 가 호출된다. 저 c 코드를 살펴보면,    
`signal(SIGALRM,sig_handler);` 로 `SIGALRM` 시그널이 발생하면 `sig_handler` 함수를 실행시킨다.    

근데 이게 프로세스에서 모든 걸 처리하는 것처럼 보이겠지만 사실 `SIGALRM` 시그널이 발생하면 커널모드로 진입한다.     

그 말은 곧 커널모드에서 유저모드로 돌아올 때 유저모드의 상태를 기억하고 있어야한다.  
그리고 그런 것들을 다 기억하는 함수는 `do_signal` 얘다.   

<br>


### **do_signal**

리눅스 커널 버전에 따라 `do_signal` (5.8 이하),  `arch_do_signal` (5.10 이하), `arch_do_signal_or_restart` (5.10 상위버전) 으로 다르다.   
아무튼 **do_signal** 은 시그널을 처리하기 위해 제일 먼저 호출되는 함수다.  


```c
void arch_do_signal_or_restart(struct pt_regs *regs, bool has_signal)
{
	struct ksignal ksig;
	if (has_signal && get_signal(&ksig)) {
		/* Whee! Actually deliver the signal.  */
		handle_signal(&ksig, regs);
		return;
	}
	/* Did we come from a system call? */
	if (syscall_get_nr(current, regs) >= 0) {
		/* Restart the system call - no handlers present */
		switch (syscall_get_error(current, regs)) {
		case -ERESTARTNOHAND:
		case -ERESTARTSYS:
		case -ERESTARTNOINTR:
			regs->ax = regs->orig_ax;
			regs->ip -= 2;
			break;
		case -ERESTART_RESTARTBLOCK:
			regs->ax = get_nr_restart_syscall(regs);
			regs->ip -= 2;
			break;
		}
	}
	/*
	 * If there's no signal to deliver, we just put the saved sigmask
	 * back.
	 */
	restore_saved_sigmask();
}
```

위 코드를 보면 시그널을 처리하기 위해 시그널이 발생했다면   
`if (has_signal && get_signal(&ksig))` 로 시그널이 있는지 확인하고 시그널에 대한 정보를 인자로 `get_signal`을 호출한다. 이 함수에서는 시그널에 해달하는 핸들러가 등록되어있는지 확인하고, 등록되어 있다면 시그널에 대한 정보와 레지스터 정보를 인자로 `handle_signal` 함수를 호출한다.  


<br>

### handle_signal

```c
static void
handle_signal(struct ksignal *ksig, struct pt_regs *regs)
{
    ...
	failed = (setup_rt_frame(ksig, regs) < 0);
	if (!failed) {
		fpu__clear_user_states(fpu);
	}
	signal_setup_done(failed, ksig, stepping);
}
```

위 함수의 일부 코드인데, 여기서 `set_up_frame` 함수를 호출하는 것을 볼 수 있다.   


```c
regs->si = (unsigned long)&frame->info;
regs->dx = (unsigned long)&frame->uc;
regs->ip = (unsigned long) ksig->ka.sa.sa_handler;
regs->sp = (unsigned long)frame;
```

시그널에 맞는 핸들러가 존재하면 핸들러의 주소를 다음 실행 주소로 삽입한다.    
위 코드는 `sig_handler` 함수의 호출 과정이다.   

<br>

### **sigreturn**

현재 프로세스가 바뀌는 걸 **Context Switching** 이라고 한다.  
커널이 유저가 실행한 프로세스를 관리하기 위해 이런저런 코드들을 실행하는데 이런 컨텍스트 스위칭이 일어나면 다시 유저 프로세스로 복귀를 해야한다.  

그래서 스위칭이 일어날 때 상황을 커널에서 기억하고 복귀를 해야하는데, 이때 사용되는 시스템콜이 **sigreturn** 이다.   


```c
static bool restore_sigcontext(struct pt_regs *regs,
			       struct sigcontext __user *usc,
			       unsigned long uc_flags)
{
	struct sigcontext sc;

	/* Always make any pending restarted system calls return -EINTR */
	current->restart_block.fn = do_no_restart_syscall;

	if (copy_from_user(&sc, usc, CONTEXT_COPY_SIZE))
		return false;

#ifdef CONFIG_X86_32
	set_user_gs(regs, sc.gs);
	regs->fs = sc.fs;
	regs->es = sc.es;
	regs->ds = sc.ds;
#endif /* CONFIG_X86_32 */

	regs->bx = sc.bx;
	regs->cx = sc.cx;
	regs->dx = sc.dx;
	regs->si = sc.si;
	regs->di = sc.di;
	regs->bp = sc.bp;
	regs->ax = sc.ax;
	regs->sp = sc.sp;
	regs->ip = sc.ip;

#ifdef CONFIG_X86_64
	regs->r8 = sc.r8;
	regs->r9 = sc.r9;
	regs->r10 = sc.r10;
	regs->r11 = sc.r11;
	regs->r12 = sc.r12;
	regs->r13 = sc.r13;
	regs->r14 = sc.r14;
	regs->r15 = sc.r15;
#endif /* CONFIG_X86_64 */

	/* Get CS/SS and force CPL3 */
	regs->cs = sc.cs | 0x03;
	regs->ss = sc.ss | 0x03;

	regs->flags = (regs->flags & ~FIX_EFLAGS) | (sc.flags & FIX_EFLAGS);
	/* disable syscall checks */
	regs->orig_ax = -1;

#ifdef CONFIG_X86_64
	/*
	 * Fix up SS if needed for the benefit of old DOSEMU and
	 * CRIU.
	 */
	if (unlikely(!(uc_flags & UC_STRICT_RESTORE_SS) && user_64bit_mode(regs)))
		force_valid_ss(regs);
#endif

	return fpu__restore_sig((void __user *)sc.fpstate,
			       IS_ENABLED(CONFIG_X86_32));
}
```

위 코드를 살펴보면 `restore_sigcontext` 함수로, `sigcontext` 구조체에 존재하는 각 멤버 변수에 값을 삽입하는 걸 볼 수 있다.    


구조체는 아래 코드에 나와있다. 멤버 변수 순서는 값 복사 순서랑 상관없으므로 순서는 외우지 않아도 된다.   


```c
/* __x86_64__: */
struct sigcontext {
  __u64               r8;
  __u64               r9;
  __u64               r10;
  __u64               r11;
  __u64               r12;
  __u64               r13;
  __u64               r14;
  __u64               r15;
  __u64               rdi;
  __u64               rsi;
  __u64               rbp;
  __u64               rbx;
  __u64               rdx;
  __u64               rax;
  __u64               rcx;
  __u64               rsp;
  __u64               rip;
  __u64               eflags;     /* RFLAGS */
  __u16               cs;
  __u16               gs;
  __u16               fs;
  union {
      __u16           ss; /* If UC_SIGCONTEXT_SS */
      __u16           __pad0; /* Alias name for old (!UC_SIGCONTEXT_SS) user-space */
  };
  __u64               err;
  __u64               trapno;
  __u64               oldmask;
  __u64               cr2;
  struct _fpstate __user      *fpstate;   /* Zero when no FPU context */
#  ifdef __ILP32__
  __u32               __fpstate_pad;
#  endif
  __u64               reserved1[8];
};
```


 <br>

### SROP

이제 다시 주제로 돌아와서 SROP란 컨텍스트 스위칭을 위해 사용하는 sigreturn 시스템 콜을 이용한 ROP 기법이다.  

```c
// Name: sigrt_call.c
// Compile: gcc -o sigrt_call sigrt_call.c 
#include <string.h>

int main()
{
        char buf[1024];
        memset(buf, 0x41, sizeof(buf));

        asm("mov $15, %rax;"
            "syscall");
}
```

위 c 코드는 간단하게, buf 크기만큼 0x41 (A) 를 집어넣고 시스템 콜 15번에 해당하는 rt_sigreturn 을 실행하는 코드이다.  

위 상황에서는 시스템 콜을 호출해서 레지스터를 스택의 값으로 조작한다   

<br>


<img width="1439" height="882" alt="image" src="https://github.com/user-attachments/assets/60a15aae-9a71-41c6-84e7-74ad9bdb8949" />


스택에 값을 쓸 수 있고 sigreturn 시스템 콜을 호출할 수 있는 상황이라면 모든 레지스터를 원하는대로 조작할 수 있기 때문에 공격에 유용하게 쓸 수 있는 기법 중 하나이다.  
